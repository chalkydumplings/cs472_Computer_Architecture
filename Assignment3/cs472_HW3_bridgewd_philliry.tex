\documentclass[letterpaper,12pt,titlepage]{article}

\usepackage{graphicx}                                        
\usepackage{amssymb}                                         
\usepackage{amsmath}                                         
\usepackage{amsthm}                                          

\usepackage{alltt}                                           
\usepackage{float}
\usepackage{color}
\usepackage{url}

\usepackage[framemethod=TikZ]{mdframed}
\mdfdefinestyle{MyFrame}{%
    innertopmargin=\baselineskip,
    innerbottommargin=\baselineskip,
    innerrightmargin=20pt,
    innerleftmargin=20pt,
    backgroundcolor=gray!10!white}

\usepackage{listings}
\usepackage{xcolor}
\usepackage{color}
\usepackage[font=small,format=plain,labelfont=bf,up,textfont=it,up]{caption}

\usepackage{balance}
\usepackage[TABBOTCAP, tight]{subfigure}
\usepackage{enumitem}
\usepackage{pstricks, pst-node}

%%keeps text of subsection on same line
\usepackage{titlesec} 
\titleformat{\subsection}[runin] 
  {\normalfont\large\bfseries}{\thesubsection}{1em}{} 
  
\usepackage{geometry}
\geometry{textheight=9in, textwidth=6.5in}

%random comment

\newcommand{\cred}[1]{{\color{red}#1}}
\newcommand{\cblue}[1]{{\color{blue}#1}}

\usepackage{hyperref}
\usepackage{geometry}

%% Code Listing Configuration
\renewcommand{\lstlistingname}{Code}
\lstset{ %
  %Some lang opts: C++, C, Java, Python, Matlab, TeX, HTML, SQL, Verilog, VHDL, make, ...
  basicstyle=\footnotesize\ttfamily , % the size of the fonts that are used for the code
  numbers=left,                       % where to put the line-numbers
  numberstyle=\scriptsize\color{darkgray}, % the style that is used for the line-numbers
  stepnumber=2,                       % the step between two line-numbers. 
  numbersep=5pt,                      % how far the line-numbers are from the code
  backgroundcolor=\color{white},      % choose the background color. You must add \usepackage{color}
  showspaces=false,                   % show spaces adding particular underscores
  showstringspaces=false,             % underline spaces within strings
  showtabs=false,                     % show tabs within strings adding particular underscores
  frame=tb,                           % adds a frame around the code
  rulesepcolor=\color{gray},          % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
  tabsize=2,                          % sets default tabsize to 2 spaces
  captionpos=t,                       % sets the caption-position
  breaklines=true,                    % sets automatic line breaking
  breakatwhitespace=false,            % sets if automatic breaks should only happen at whitespace
  title=\lstname,                     % show the filename of files included with \lstinputlisting;
  keywordstyle=\color{blue},          % keyword style
  commentstyle=\color{dkgreen},       % comment style
  stringstyle=\color{mauve},          % string literal style
  escapeinside={\%*}{*)},             % if you want to add a comment within your code
  morekeywords={*,...}                % if you want to add more keywords to the set
  framexbottommargin=5pt,
}

\def\name{Drake Bridgewater \& Ryan Phillips}

%% The following metadata will show up in the PDF properties
\hypersetup{
  colorlinks = true,
  urlcolor = black,
  pdfauthor = {\name},
  pdfkeywords = {cs472 ``computer architecture'' clements ``chapter 2''},
  pdftitle = {CS 472: Homework 3},
  pdfsubject = {CS 472: Homework 3},
  pdfpagemode = UseNone
}

\begin{document}
\hfill \name

\hfill \today

\hfill CS 472 HW 3

\section*{$(3.1)$} Why is the program counter a pointer and not a counter? 

\begin{mdframed}[style=MyFrame]

It saves a step. If it were a counter, an address would still need to be stored somewhere, and arithmatic on this address would need to be performed using the counter. But since the program instructions are stored sequentially in memory, the address itself can simply be incremented to get the next instruction.

\end{mdframed}
  
\section*{$(3.2)$} Explain the function of the following registers in a CPU.

\renewcommand{\labelenumi}{\alph{enumi})}
\begin{enumerate}
\item PC

\begin{mdframed}[style=MyFrame]

The Program Counter. It is incremented after an instruction is fetched. It holds the memory address of the next instruction to be executed.

\end{mdframed}

\item MAR

\begin{mdframed}[style=MyFrame]

The Memory Address Register. It works in tandom with the MDR. It either contains the location of the where the MDR data should be written to, or the location of data which will be read into the MDR.

\end{mdframed}

\item MDR 

\begin{mdframed}[style=MyFrame]

The Memory Data Register. It contains the data referred to in the MAR explanation above.

\end{mdframed}
\newpage
\item IR

\begin{mdframed}[style=MyFrame]

Instruction Register. This contains the instruction which is currently being executed. It is fetched from the location pointed to by the PC.

\end{mdframed}

\end{enumerate}

\section*{$(3.3)$} For each of the following 6-bit operations, calculate the values of the C, Z, V, and N flags.

\subsection*{a.}
\begin{mdframed}[style=MyFrame]
\begin{tabular}{c c}

$\begin{array}[t]{r}
   001011 \\
  +001101 \\\hline
   011000 \\
\end{array}$
&
C = 0,
Z = 0,
V = 0,
N = 0
\end{tabular}
\end{mdframed}

\subsection*{b.}

\begin{mdframed}[style=MyFrame]
\begin{tabular}{c c}
$\begin{array}[t]{r}
   111111 \\
  +000001 \\\hline
  1000000 \\
\end{array}$

C = 1,
Z = 1,
V = 0,
N = 0
\end{tabular}
\end{mdframed}

\subsection*{c.}
\begin{mdframed}[style=MyFrame]
\begin{tabular}{c c}
$\begin{array}[t]{r}
   000000 \\
  -111111 \\\hline
   111111 \\
\end{array}$


C = 0,
Z = 0,
V = 1,
N = 1
\end{tabular}
\end{mdframed}

\subsection*{d}
\begin{mdframed}[style=MyFrame]
\begin{tabular}{c c}
$\begin{array}[t]{r}
   101101 \\
  +011011 \\\hline
  1001000 \\
\end{array}$

C = 1,
Z = 0,
V = 0,
N = 1
\end{tabular}
\end{mdframed}
\newpage
\subsection*{e}
\begin{mdframed}[style=MyFrame]
\begin{tabular}{c c}
$\begin{array}[t]{r}
   000000 \\
  -000001 \\\hline
   111110 \\
\end{array}$

C = 0,
Z = 0,
V = 0,
N = 1
\end{tabular}
\end{mdframed}

\subsection*{f.}
\begin{mdframed}[style=MyFrame]
\begin{tabular}{c c}
$\begin{array}[t]{r}
   111110 \\
  +111111 \\\hline
  1111101 \\
\end{array}$

C = 1,
Z = 0,
V = 1,
N = 1
\end{tabular}
\end{mdframed}

\section*{$(3.10)$} Why does the ARM provide a reverse subtract instruction RSB r0,r1,r2 that implements [r0] = [r2] - [r1] when the normal subtraction instruction SUB r0,r2,r1 will do exactly the same job? \newline
>>>>>>> 010ec48eb31da9db479ba7db1086a18039b30501

\begin{mdframed}[style=MyFrame]
These two operand only differ by the order of operation, and can be seen as unnecessary as switching the two operands for SUB should suffice. The problem arises when only the second operand can be constant or other special forms. All operations could be done using the SUB operations but additional registers would be necessary as seen  in this example: $SUB~R2,~R4,~\#8$ if you wanted to do the exact opposite you would need an an additional register to hold the constant $\#8$, but using RSB it would just be $RSB~R2,~R4,~\#8$
\end{mdframed}

\newpage
\section*{$(3.17)$} ARM instructions have a 12-bit literal. Instead of permitting a word in the range 0 to $2^12 - 1$, the ARM uses an 8-bit format for the integer and a 4-bit alignment field that allows the integer to be shifted in steps of two. What are the advantages and disadvantages of this mechanism in comparison to a straight 12-bit integer? \newline

\begin{mdframed}[style=MyFrame]
These 8-bit literal that can be scaled by a power of 2. you could even say that arm provides a type of floating point literal. 

The four most significant bits of the literal field specify the literal's alignment within a 32-bit word. if the 8 bit immediate value is N and the 4-bit alignment is n in the range 0-12 then the value of the literal is given by $N\times2^{2n}$. Thus, arm provides an 8-bit literal that is scaled by a power of 2. 
\end{mdframed}


\section*{$(3.18)$} Write one or more ARM instructions that will clear bits 20 to 25 inclusive in register r0. All the other bits of r0 should remain unchanged.
\begin{mdframed}[style=MyFrame]
$LDR~~~ R3, = 0xFC0F~FFFF $\\
$AND~~~ R0,R3,R0$
\end{mdframed}

\begin{lstlisting}
    AREA clearbits, CODE, READONLY 
    ENTRY
start
    AND r0,r0,#2_11111111111111111110000001111111
    END
\end{lstlisting}

\newpage

\section*{$(3.19)$} This is a classic problem of assembly language programming. Write a sequence of ARM instructions that swap the contents of registers r0 and r2 without using any additional registers or memory storage (that is, you can't move r1 to a temporary location).
\begin{mdframed}[style=MyFrame]
Our original thought similar the the integer implementation where you add them and together and subtract the other like this
\begin{verbatim}
x=15;
y=21;

x=x+y;
y=x-y;
x=x-y;
\end{verbatim}
But we had some concern with the S bits. This lead us to some research online where we found an article titled \textbf{The Magic of XOR} \cite{Charles} which introduced us to an extremely fascinating method of swapping two values. This process is basically XORing the three times as the pseudocode below depicts.
\begin{verbatim}
x=1101;
y=0110;

x=x EOR y;       //1101 EOR 0110 = 1011
y=x EOR y;       //1011 EOR 0110 = 1101
x=x EOR y;       //1011 EOR 1101 = 0110
\end{verbatim}
\vspace{-0.5cm}
\end{mdframed}

\newpage
\section*{$(3.25)$} What is the binary encoding of the following instructions?

\renewcommand{\labelenumi}{\alph{enumi})}
\begin{enumerate}

\item STRB r1, [r2]

\begin{mdframed}[style=MyFrame]
E5C21000 $\rightarrow$ 11100101110000100001000000000000
\end{mdframed}

\item LDR r3, [r4, r5]!

\begin{mdframed}[style=MyFrame]
E7B43005 $\rightarrow$ 11100111101101000011000000000101
\end{mdframed}

\item LDR r3, [r4], r5

\begin{mdframed}[style=MyFrame]
E6943005 $\rightarrow$ 11100110100101000011000000000101
\end{mdframed}

\item LDR r3, [r4,\#-6]! 

\begin{mdframed}[style=MyFrame]
E5343006 $\rightarrow$ 11100101001101000011000000000110
\end{mdframed}

\end{enumerate}


\section*{$(3.51)$} Write an ARM assembly language program to determine whether a string of characters with an odd length is a palindrome (for example, mom) under the following constraints.

a. The string of ASIC-encoded characters is stored in memory.

b. At the start of the program, register r1 contains the address of the first character in the string, and r2 contains the address of the last character. On exit from the program, register r0 contains a 0 if the string is a not a palindrome, and 1 if it is. \newline

\begin{mdframed}[style=MyFrame]
todo...
\end{mdframed}

\bibliographystyle{plain}
\bibliography{cs472_HW3_bridgewd_philliry}
\end{document}

