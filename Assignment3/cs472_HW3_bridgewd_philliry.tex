\documentclass[letterpaper,12pt,titlepage]{article}

\usepackage{graphicx}                                        
\usepackage{amssymb}                                         
\usepackage{amsmath}                                         
\usepackage{amsthm}                                          

\usepackage{alltt}                                           
\usepackage{float}
\usepackage{color}
\usepackage{url}

\usepackage[framemethod=TikZ]{mdframed}
\mdfdefinestyle{MyFrame}{%
    innertopmargin=\baselineskip,
    innerbottommargin=\baselineskip,
    innerrightmargin=20pt,
    innerleftmargin=20pt,
    backgroundcolor=gray!10!white}

\usepackage{balance}
\usepackage[TABBOTCAP, tight]{subfigure}
\usepackage{enumitem}
\usepackage{pstricks, pst-node}

%%keeps text of subsection on same line
\usepackage{titlesec} 
\titleformat{\subsection}[runin] 
  {\normalfont\large\bfseries}{\thesubsection}{1em}{} 
  
\usepackage{geometry}
\geometry{textheight=9in, textwidth=6.5in}

%random comment

\newcommand{\cred}[1]{{\color{red}#1}}
\newcommand{\cblue}[1]{{\color{blue}#1}}

\usepackage{hyperref}
\usepackage{geometry}

\def\name{Drake Bridgewater \& Ryan Phillips}

%% The following metadata will show up in the PDF properties
\hypersetup{
  colorlinks = true,
  urlcolor = black,
  pdfauthor = {\name},
  pdfkeywords = {cs472 ``computer architecture'' clements ``chapter 2''},
  pdftitle = {CS 472: Homework 3},
  pdfsubject = {CS 472: Homework 3},
  pdfpagemode = UseNone
}

\begin{document}
\hfill \name

\hfill \today

\hfill CS 472 HW 3

\section*{$(3.1)$} Why is the program counter a pointer and not a counter? \newline



\begin{mdframed}[style=MyFrame]

It saves a step. If it were a counter, an address would still need to be stored somewhere, and arithmatic on this address would need to be performed using the counter. But since the program instructions are stored sequentially in memory, the address itself can simply be incremented to get the next instruction.

\end{mdframed}
  
\section*{$(3.2)$} Explain the function of the following registers in a CPU.

\renewcommand{\labelenumi}{\alph{enumi})}
\begin{enumerate}
\item PC

\begin{mdframed}[style=MyFrame]

The Program Counter. It is incremented after an instruction is fetched. It holds the memory address of the next instruction to be executed.

\end{mdframed}

\item MAR

\begin{mdframed}[style=MyFrame]

The Memory Address Register. It works in tandom with the MDR. It either contains the location of the where the MDR data should be written to, or the location of data which will be read into the MDR.

\end{mdframed}

\item MDR 

\begin{mdframed}[style=MyFrame]

The Memory Data Register. It contains the data referred to in the MAR explanation above.

\end{mdframed}

\item IR

\begin{mdframed}[style=MyFrame]

Instruction Register. This contains the instruction which is currently being executed. It is fetched from the location pointed to by the PC.

\end{mdframed}

\end{enumerate}

\section*{$(3.3)$} For each of the following 6-bit operations, calculate the values of the C, Z, V, and N flags.

\subsection*{a.}

$\begin{array}[t]{r}
   001011 \\
  +001101 \\\hline
   011000 \\
\end{array}$

\begin{mdframed}[style=MyFrame]

C = 0
Z = 0
V = 0
N = 0

\end{mdframed}

\subsection*{b.}

$\begin{array}[t]{r}
   111111 \\
  +000001 \\\hline
  1000000 \\
\end{array}$

\begin{mdframed}[style=MyFrame]

C = 0
Z = 0
V = 0
N = 0

\end{mdframed}

\subsection*{c.}

000000
111111
-

\subsection*{d}

101101
011011
+

\subsection*{e}

000000
000001
-

\subsection*{f.}

111110
111111
+

\section*{$(3.10)$} Why does the ARM provide a reverse subtract instruction RSB r0,r1,r2 that implements [r0] = [r2] - [r1] when the normal subtraction instruction SUB r0,r2,r1 will do exactly the same job?

\begin{mdframed}[style=MyFrame]
These two operand only differ by the order of operation, and can be seen as unnecessary as switching the two operands for SUB should suffice. The problem arises when only the second operand can be constant or other special forms. All operations could be done using the SUB operations but additional registers would be necessary as seen  in this example: $SUB~R2,~R4,~\#8$ if you wanted to do the exact opposite you would need an an additional register to hold the constant $\#8$, but using RSB it would just be $RSB~R2,~R4,~\#8$
\end{mdframed}

\section*{$(3.17)$} ARM instructions have a 12-bit literal. Instead of permitting a word in the range 0 to 2^12 - 1, the ARM uses an 8-bit format for the integer and a 4-bit alignment field that allows the integer to be shifted in steps of two. What are the advantages and disadvantages of this mechanism in comparison to a straight 12-bit integer?

\begin{mdframed}[style=MyFrame]
todo...
\end{mdframed}

\section*{$(3.18)$} Write one or more ARM instructions that will clear bits 20 to 25 inclusive in register r0. All the other bits of r0 should remain unchanged.

    AREA clearbits, CODE, READONLY 
    ENTRY
    
start
    AND r0,r0,#2_11111111111111111110000001111111
    
    END

\section*{$(3.19)$} This is a classic problem of assembly language programming. Write a sequence of ARM instructions that swap the contents of registers r0 and r2 without using any additional registers or memory storage (that is, you can't move r1 to a temporary location).

    AREA swap, CODE, READONLY 
    ENTRY
    
start
    EOR r0,r2,r0
    EOR r2,r2,r0
    EOR r0,r2,r0
    
    END

\section*{$(3.25)$} What is the binary encoding of the following instructions?

\renewcommand{\labelenumi}{\alph{enumi})}
\begin{enumerate}

\item STRB r1, [r2]

\begin{mdframed}[style=MyFrame]
E5C21000 \rightarrow 11100101110000100001000000000000
\end{mdframed}

\item LDR r3, [r4, r5]!

\begin{mdframed}[style=MyFrame]
E7B43005 \rightarrow 11100111101101000011000000000101
\end{mdframed}

\item LDR r3, [r4], r5

\begin{mdframed}[style=MyFrame]
E6943005 \rightarrow 11100110100101000011000000000101
\end{mdframed}

\item LDR r3, [r4,\#-6]! 

\begin{mdframed}[style=MyFrame]
E5343006 \rightarrow 11100101001101000011000000000110
\end{mdframed}

\end{enumerate}

\section*{$(3.39)$} Write an ARM assembly language program that scans a string terminated by the null byte 0x00 and copies the string from a source location pointed at by r0 to a destination pointed at by r1.

\begin{mdframed}[style=MyFrame]
todo...
\end{mdframed}

\section*{$(3.51)$} Write an ARM assembly language program to determine whether a string of characters with an odd length is a palindrome (for example, mom) under the following constraints.

a. The string of ASIC-encoded characters is stored in memory.

b. At the start of the program, register r1 contains the address of the first character in the string, and r2 contains the address of the last character. On exit from the program, register r0 contains a 0 if the string is a not a palindrome, and 1 if it is.

\begin{mdframed}[style=MyFrame]
todo...
\end{mdframed}

\bibliographystyle{plain}
\bibliography{cs472_HW3_bridgewd_philliry}
\end{document}

