\documentclass[letterpaper,12pt,titlepage]{article}

\usepackage{graphicx}                                        
\usepackage{amssymb}                                         
\usepackage{amsmath}                                         
\usepackage{amsthm}                                          

\usepackage{alltt}                                           
\usepackage{float}
\usepackage{color}
\usepackage{url}

\usepackage[framemethod=TikZ]{mdframed}
\mdfdefinestyle{MyFrame}{%
    innertopmargin=\baselineskip,
    innerbottommargin=\baselineskip,
    innerrightmargin=20pt,
    innerleftmargin=20pt,
    backgroundcolor=gray!10!white}

\usepackage{balance}
\usepackage[TABBOTCAP, tight]{subfigure}
\usepackage{enumitem}
\usepackage{pstricks, pst-node}

\usepackage{geometry}
\geometry{textheight=9in, textwidth=6.5in}

%random comment

\newcommand{\cred}[1]{{\color{red}#1}}
\newcommand{\cblue}[1]{{\color{blue}#1}}

\usepackage{hyperref}
\usepackage{geometry}

\def\name{Drake Bridgewater \& Ryan Phillips}

%% The following metadata will show up in the PDF properties
\hypersetup{
  colorlinks = true,
  urlcolor = black,
  pdfauthor = {\name},
  pdfkeywords = {cs472 ``computer architecture'' clements ``chapter 2''},
  pdftitle = {CS 472: Homework 3},
  pdfsubject = {CS 472: Homework 3},
  pdfpagemode = UseNone
}

\begin{document}
\hfill \name

\hfill \today

\hfill CS 472 HW 3

\section*{$(3.1)$} Why is the program counter a pointer and not a counter? \newline



\begin{mdframed}[style=MyFrame]

It saves a step. If it were a counter, an address would still need to be stored somewhere, and arithmatic on this address would need to be performed using the counter. But since the program instructions are stored sequentially in memory, the address itself can simply be incremented to get the next instruction.

\end{mdframed}
  
\section*{$(3.2)$} Explain the function of the following registers in a CPU.

\renewcommand{\labelenumi}{\alph{enumi})}
\begin{enumerate}
\item PC

\begin{mdframed}[style=MyFrame]

The Program Counter. It is incremented after an instruction is fetched. It holds the memory address of the next instruction to be executed.

\end{mdframed}

\item MAR

\begin{mdframed}[style=MyFrame]

The Memory Address Register. It works in tandom with the MDR. It either contains the location of the where the MDR data should be written to, or the location of data which will be read into the MDR.

\end{mdframed}

\item MDR 

\begin{mdframed}[style=MyFrame]

The Memory Data Register. It contains the data referred to in the MAR explanation above.

\end{mdframed}

\item IR

\begin{mdframed}[style=MyFrame]

The Memory Data Register. It contains the data referred to in the MAR explanation above.

\end{mdframed}

\end{enumerate}

\section*{$(3.3)$} For each of the following 6-bit operations, calculate the values of the C, Z, V, and N flags.

a.

001011
001101
+

b. 

111111
000001
+

c.

000000
111111
-

d. 

101101
011011
+

e.

000000
000001
-

f.

111110
111111
+

\section*{$(3.10)$} Why does the ARM provide a reverse subtract instruction RSB r0,r1,r2 that implements [r0] = [r2] - [r1] when the normal subtraction instruction SUB r0,r2,r1 will do exactly the same job?

\section*{$(3.17)$} 

\section*{$(3.18)$} Write one or more ARM instructinos that will clear bits 20 to 25 inclusive in register r0. All the other bits of r0 should remain unchanged.

\section*{$(3.19)$} This is a classic problem of assembly language programming. Write a sequence of ARM instructions that swap the contents of registers r0 and r2 without using any additional registers or memory storage (that is, you can't move r1 to a temporary location).

\section*{$(3.25)$} What is the binary encoding of the following instructions?


\renewcommand{\labelenumi}{\alph{enumi})}
\begin{enumerate}

\item STRB r1, [r2]

\item LDR r3, [r4, r5]!

\item LDR r3, [r4], r5

\item LDR r3, [r4,\#-6]!

\end{enumerate}

\section*{$(3.39)$} Write an ARM assembly language program that scans a string terminated by the null byte 0x00 and copies the string from a source location pointed at by r0 to a destination pointed at by r1.

\section*{$(3.51)$} Write an ARM assembly language program to determine whether a string of characters with an odd length is a palindrome (for example, mom) under the following constraints.

a. The string of ASIC-encoded characters is stored in memory.

b. At the start of the program, register r1 contains the address of the first character in the string, and r2 contains the address of the last character. On exit from the program, register r0 contains a 0 if the string is a not a palindrome, and 1 if it is.

\bibliographystyle{plain}
\bibliography{cs472_HW2_bridgewd_philliry}
\end{document}

